defmodule Lichen.Winnowing do
  @moduledoc """
  A module in charge of performing the actual fingerprinting and winnowing algorithm.
  """

  @k 40
  @t 80

  @doc """
  Fingerprints the given input text or stream. Fingerprints are generated by hashing n-grams
  of the source using SHA-1, and taking the first 16 bits. Then, the winnowing algorithm
  is used to select which fingerprints to keep.

  Input can be provided either as just a string, or an `Enumerable` of tuples in the
  form `{token, start_index}` for backtracking matches.
  """
  @spec winnow(String.t() | [{String.t(), integer()}]) :: [integer()]
  def winnow(input)

  def winnow(input) when is_binary(input) do
    winnow([{input, 0}])
  end

  def winnow(input) do
    input
    |> expand_tokens()
    |> Stream.chunk_every(@k, 1)
    |> collapse_ngrams()
    |> Stream.map(&hash_ngram/1)
    |> select_hashes(@t - @k + 1)
    |> Enum.to_list()
  end

  defp expand_tokens(tokens) do
    Stream.flat_map(tokens, fn {token, i} ->
      token
      |> String.graphemes()
      |> Stream.with_index(i)
    end)
  end

  defp collapse_ngrams(ngrams) do
    Stream.map(ngrams, fn ngram ->
      {
        ngram |> Enum.map(&elem(&1, 0)) |> Enum.join(),
        ngram |> hd |> elem(1)
      }
    end)
  end

  defp hash_ngram({str, i}) do
    <<x::16, _::binary>> = :crypto.hash(:sha, str)
    {x, i}
  end

  defp select_hashes(fingerprints, size) do
    fingerprints
    |> Stream.chunk_every(size, 1)
    |> Stream.with_index()
    |> Stream.map(fn {window, idx} ->
      window
      |> Enum.with_index(idx)
      |> Enum.reverse()
      |> Enum.min()
    end)
    |> Stream.dedup_by(&elem(&1, 1))
    |> Enum.map(&elem(&1, 0))
  end
end
